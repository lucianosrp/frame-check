{"config":{"lang":["en"],"separator":"\\.","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Warning</p> <p>This project is currently under active development and is not considered polished. You are welcome to fork it, contribute to making it more stable, or raise issues.</p>"},{"location":"#frame-check","title":"frame-check","text":"<p>A static checker for pandas DataFrames</p>"},{"location":"#why-frame-check","title":"Why frame-check?","text":"<p>Working with pandas DataFrames can be error-prone when it comes to column access. How many times have you written code like this, unsure if the column actually exists?</p> <pre><code># Will this work? \ud83e\udd14\nresult = df[\"customer_id\"]\nfiltered = df[df[\"status\"] == \"active\"]\n</code></pre> <p>The current reality:</p> <ul> <li> <p>\u2705 Code runs fine in development with your test data</p> </li> <li> <p>\u274c Crashes in production when a column is missing</p> </li> <li> <p>\ud83d\ude30 Hours spent debugging runtime <code>KeyError</code> exceptions</p> </li> </ul>"},{"location":"#the-problem","title":"The Problem","text":"<p>When accessing DataFrame columns, you typically have to choose between:</p> <ol> <li>Manual verification - Tediously trace through your code to verify every column reference</li> <li>Runtime checks - Add defensive programming with <code>if 'column' in df.columns:</code> everywhere</li> <li>Source check - Verify columns existence in your file or database schema</li> <li>Cross your fingers - Hope the columns exist and deal with crashes later</li> </ol> <pre><code># Defensive programming gets verbose quickly\nif 'customer_id' in df.columns and 'status' in df.columns:\n    result = df[df[\"status\"] == \"active\"][\"customer_id\"]\nelse:\n    raise ValueError(\"Missing required columns\")\n</code></pre>"},{"location":"#the-solution","title":"The Solution","text":"<p>frame-check brings static analysis to pandas DataFrames - just like <code>mypy</code> does for Python types. It tracks DataFrame schemas through your code and catches column access errors before your code runs.</p>"},{"location":"#see-it-in-action","title":"See it in action:","text":"<pre><code>import pandas as pd\n\n# frame-check knows this DataFrame has columns: Name, Age, City, Salary\ndf = pd.DataFrame({\n    \"Name\": [\"Alice\", \"Bob\"],\n    \"Age\": [25, 30],\n    \"City\": [\"NYC\", \"LA\"],\n    \"Salary\": [50000, 60000]\n})\n\n# \u274c This will be caught by frame-check\nresult = df[\"customer_id\"]  # Column doesn't exist!\n</code></pre> <pre><code>frame-check example.py\n</code></pre> <p>Error output: <pre><code>example.py:12:10 - error: Column 'customer_id' does not exist\n  |\n12| result = df[\"customer_id\"]\n  |          ^^^^^^^^^^^^^^^^^\n  |\n  | DataFrame 'df' was defined at line 4 with columns:\n  |   \u2022 Name\n  |   \u2022 Age\n  |   \u2022 City\n  |   \u2022 Salary\n  |\n</code></pre></p>"},{"location":"#key-benefits","title":"Key Benefits","text":"<ul> <li>\ud83d\ude80 Catch errors early - Find column access issues during development, not production</li> <li>\ud83e\udde0 Smart tracking - Understands DataFrame transformations like <code>groupby()</code>, <code>assign()</code>, and column assignments</li> <li>\ud83d\udd27 Editor integration - Real-time error highlighting in your favorite editor via LSP</li> <li>\ud83d\udcdd Clear diagnostics - Helpful error messages that show exactly where DataFrames were defined</li> <li>\u26a1 Zero runtime overhead - Pure static analysis, no impact on your running code</li> </ul> <p>frame-check - Because DataFrame bugs shouldn't be a surprise! \ud83d\udc3c\u2728</p>"},{"location":"#how-to-install","title":"How to install","text":"git clone + uv (Manual dev install) <pre><code>git clone https://github.com/lucianosrp/frame-check.git\ncd frame-check/frame-check-core\nuv tool install . -e\n</code></pre>"},{"location":"editor/","title":"How to install","text":""},{"location":"editor/#zed","title":"Zed","text":"<ul> <li> <p>Ctrl+Shift+X</p> </li> <li> <p>Click on \"Install Dev Extensions\" and select the directory <code>frame-check-extensions/zed</code>.</p> </li> </ul>"},{"location":"summary/","title":"Summary","text":"<ul> <li>Features<ul> <li>Dataframe Creation Methods</li> <li>Column Assignment Methods</li> <li>Column Removal Methods</li> <li>Edge Cases</li> </ul> </li> </ul>"},{"location":"features/","title":"Pandas Features","text":"<p>Frame-check supports various pandas features and usage patterns:</p> <ul> <li>Dataframe Creation Methods</li> <li>Column Assignment Methods</li> <li>Column Removal Methods</li> <li>Edge Cases</li> </ul>"},{"location":"features/column_assignment_methods/","title":"Column Assignment Methods","text":""},{"location":"features/column_assignment_methods/#cam-1-direct-assignment","title":"CAM-1: Direct assignment","text":"<p><pre><code>df[\"c\"] = [7, 8, 9]\n</code></pre> The most common method for assigning values to a column. If the column doesn't exist, it creates a new one.</p> <p>Supported </p>"},{"location":"features/column_assignment_methods/#cam-2-attribute-assignment","title":"CAM-2: Attribute assignment","text":"<p><pre><code>df.col = value\n</code></pre> Works only for valid Python identifiers. Not recommended for production code due to potential conflicts with DataFrame methods.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-3-loc-indexer","title":"CAM-3: loc indexer","text":"<p><pre><code>df.loc[:, 'col'] = value\n</code></pre> Label-based column assignment that can assign to slices or selections of rows.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-4-iloc-indexer","title":"CAM-4: iloc indexer","text":"<p><pre><code>df.iloc[:, index] = value\n</code></pre> Position-based assignment that uses integer indices instead of column labels.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-5-at-indexer","title":"CAM-5: at indexer","text":"<p><pre><code>df.at[row, 'col'] = value\n</code></pre> For single cell assignment based on labels. Faster than loc for single-cell operations.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-6-iat-indexer","title":"CAM-6: iat indexer","text":"<p><pre><code>df.iat[row, col_idx] = value\n</code></pre> Single cell assignment by position. Faster than iloc for single-cell operations.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-7-assign-method","title":"CAM-7: assign method","text":"<p><pre><code>df = df.assign(A=[1, 2, 3])\n</code></pre> Returns a new DataFrame with the column added or modified. Great for method chaining.</p> <p>Tested but not supported </p>"},{"location":"features/column_assignment_methods/#cam-8-multiple-assign","title":"CAM-8: Multiple assign","text":"<p><pre><code>df = df.assign(B=1, C=2)\n</code></pre> Creates multiple columns at once using keyword arguments.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-9-insert-method","title":"CAM-9: insert method","text":"<p><pre><code>df.insert(0, \"A\", [1, 2, 3])\n</code></pre> Inserts a column at a specific position in the DataFrame. Modifies in place.</p> <p>Supported </p>"},{"location":"features/column_assignment_methods/#cam-10-setitem-with-list","title":"CAM-10: setitem with list","text":"<p><pre><code>df[[\"c\", \"d\"]] = [[7, 8, 9], [10, 11, 12]]\n</code></pre> Assigns multiple columns at once, either from other columns or external values.</p> <p>Supported </p>"},{"location":"features/column_assignment_methods/#cam-11-from-dictionary","title":"CAM-11: From dictionary","text":"<p><pre><code>df = pd.DataFrame({'A': [1,2], 'B': [3,4]})\n</code></pre> Creates a DataFrame with the specified columns directly in the constructor.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-12-concat","title":"CAM-12: concat","text":"<p><pre><code>df = pd.concat([df, new_df], axis=1)\n</code></pre> Combines columns from two DataFrames through horizontal concatenation.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-13-join","title":"CAM-13: join","text":"<p><pre><code>df = df.join(other_df)\n</code></pre> Adds columns from another DataFrame based on index alignment.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-14-merge","title":"CAM-14: merge","text":"<p><pre><code>df = df.merge(df2, on='key')\n</code></pre> Adds columns through merging DataFrames on common columns or indices.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-15-from-eval","title":"CAM-15: From eval","text":"<p><pre><code>df.eval('C = A * 2', inplace=True)\n</code></pre> Creates columns using string expressions evaluated against the DataFrame.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-16-from-query-results","title":"CAM-16: From query results","text":"<p><pre><code>df['new'] = df.query('A &gt; 0')['B']\n</code></pre> Assigns values from a filtered subset of another column.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-17-conditional-assignment","title":"CAM-17: Conditional assignment","text":"<p><pre><code>df.loc[df['A'] &gt; 0, 'B'] = 1\n</code></pre> Updates columns only for rows matching a condition.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-18-copy-from-another-column","title":"CAM-18: Copy from another column","text":"<p><pre><code>df['B'] = df['A'].copy()\n</code></pre> Creates an explicit copy of another column.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-19-transform-operations","title":"CAM-19: Transform operations","text":"<p><pre><code>df['B'] = df['A'].apply(lambda x: x*2)\n</code></pre> Creates columns from transformations applied to existing columns.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-20-expanding-columns","title":"CAM-20: Expanding columns","text":"<p><pre><code>df[['A','B']] = df['combined'].str.split(expand=True)\n</code></pre> Creates multiple columns from string operations that expand data.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-21-from-groupby","title":"CAM-21: From groupby","text":"<p><pre><code>df['new'] = df.groupby('A')['B'].transform('mean')\n</code></pre> Creates columns containing aggregated results broadcast back to the original DataFrame's shape.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-22-from-pivot","title":"CAM-22: From pivot","text":"<p><pre><code>df.pivot(columns='A')\n</code></pre> Creates multiple columns through pivot operations that reshape the DataFrame.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-23-from-unstack","title":"CAM-23: From unstack","text":"<p><pre><code>df = df.unstack()\n</code></pre> Converts index levels to columns in a multi-index DataFrame.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-24-from-pdget_dummies","title":"CAM-24: From pd.get_dummies","text":"<p><pre><code>df = pd.get_dummies(df, columns=['A'])\n</code></pre> Creates multiple binary indicator columns from categorical columns.</p> <p>Not Supported </p>"},{"location":"features/column_assignment_methods/#cam-25-update-method","title":"CAM-25: Update method","text":"<p><pre><code>df.update(other_df[['A']])\n</code></pre> Updates existing columns with values from another DataFrame.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/","title":"Column Removal Methods","text":""},{"location":"features/column_removal_methods/#crm-1-del-statement","title":"CRM-1: del statement","text":"<p><pre><code>del df['A']\n</code></pre> In-place removal of a column using the Python del statement.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-2-drop-method","title":"CRM-2: drop method","text":"<p><pre><code>df = df.drop('A', axis=1)\n</code></pre> Returns a new DataFrame with the specified column removed.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-3-drop-with-columns","title":"CRM-3: drop with columns","text":"<p><pre><code>df = df.drop(columns=['A', 'B'])\n</code></pre> More explicit way to drop columns using the columns parameter.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-4-drop-multiple","title":"CRM-4: drop multiple","text":"<p><pre><code>df = df.drop(['A','B'], axis=1)\n</code></pre> Removes multiple columns at once using a list of column names.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-5-pop-method","title":"CRM-5: pop method","text":"<p><pre><code>removed = df.pop('A')\n</code></pre> Removes a column from the DataFrame and returns it as a Series.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-6-assign-none","title":"CRM-6: Assign None","text":"<p><pre><code>df = df.assign(col=None)\n</code></pre> Indirect method of column removal by assigning None (not common).</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-7-select-subset","title":"CRM-7: Select subset","text":"<p><pre><code>df = df[['A', 'B']]\n</code></pre> Keeps only the specified columns, effectively removing all others.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-8-loc-selection","title":"CRM-8: loc selection","text":"<p><pre><code>df = df.loc[:, ['A', 'B']]\n</code></pre> Label-based selection that keeps only the specified columns.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-9-iloc-selection","title":"CRM-9: iloc selection","text":"<p><pre><code>df = df.iloc[:, [0, 1]]\n</code></pre> Position-based selection that keeps only columns at specified indices.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-10-boolean-mask","title":"CRM-10: Boolean mask","text":"<p><pre><code>df = df.loc[:, ~df.columns.str.startswith('temp')]\n</code></pre> Uses boolean masking to remove columns based on conditions.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-11-filter-method","title":"CRM-11: filter method","text":"<p><pre><code>df = df.filter(regex='^[AB]')\n</code></pre> Keeps columns that match certain patterns, removing all others.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-12-drop_duplicates","title":"CRM-12: drop_duplicates","text":"<p><pre><code>df = df.T.drop_duplicates().T\n</code></pre> Can indirectly remove columns when applied after transposing.</p> <p>Not Supported </p>"},{"location":"features/column_removal_methods/#crm-13-reindex","title":"CRM-13: reindex","text":"<p><pre><code>df = df.reindex(columns=['A','B'])\n</code></pre> Keeps only specified columns and reorders them, removing all others.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/","title":"Dataframe Creation Methods","text":""},{"location":"features/dataframe_creation_methods/#dcms-1-dictionary-of-lists","title":"DCMS-1: Dictionary of Lists","text":"<p><pre><code>pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})\n</code></pre> Creates a DataFrame from a dictionary where keys become column names and list values become the data for each column. This is fully supported in frame-check as the primary use case.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-2-list-of-dictionaries","title":"DCMS-2: List of Dictionaries","text":"<p><pre><code>pd.DataFrame([{'col1': 1, 'col2': 3}, {'col1': 2, 'col2': 4}])\n</code></pre> Creates a DataFrame where each dictionary represents a row, with keys as column names.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-3-dictionary-of-series","title":"DCMS-3: Dictionary of Series","text":"<p><pre><code>pd.DataFrame({'col1': pd.Series([1, 2]), 'col2': pd.Series([3, 4])})\n</code></pre> Similar to dictionary of lists, but uses pandas Series objects instead.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-4-numpy-array","title":"DCMS-4: NumPy Array","text":"<p><pre><code>pd.DataFrame(np.array([[1, 2], [3, 4]]), columns=['col1', 'col2'])\n</code></pre> Creates a DataFrame from a NumPy array with explicitly defined column names.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-5-list-of-lists","title":"DCMS-5: List of Lists","text":"<p><pre><code>pd.DataFrame([[1, 2], [3, 4]], columns=['col1', 'col2'])\n</code></pre> Creates a DataFrame where each inner list represents a row, with column names provided separately.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-6-from-csv","title":"DCMS-6: From CSV","text":"<p><pre><code>pd.read_csv('file.csv', usecols=[\"a\",\"b\"])\n</code></pre> Loads data from a CSV file into a DataFrame.</p> <p>Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-7-from-json","title":"DCMS-7: From JSON","text":"<p><pre><code>pd.read_json('file.json')\n</code></pre> Loads data from a JSON file into a DataFrame.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-8-from-sql","title":"DCMS-8: From SQL","text":"<p><pre><code>pd.read_sql('SELECT * FROM table', connection)\n</code></pre> Loads data from a SQL query into a DataFrame.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-9-from-excel","title":"DCMS-9: From Excel","text":"<p><pre><code>pd.read_excel('file.xlsx')\n</code></pre> Loads data from an Excel file into a DataFrame.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-10-from-parquet","title":"DCMS-10: From Parquet","text":"<p><pre><code>pd.read_parquet('file.parquet')\n</code></pre> Loads data from a Parquet file into a DataFrame.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-11-empty-dataframe","title":"DCMS-11: Empty DataFrame","text":"<p><pre><code>pd.DataFrame()\n</code></pre> Creates an empty DataFrame with no columns or rows.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-12-from-index","title":"DCMS-12: From Index","text":"<p><pre><code>pd.DataFrame(index=['a', 'b'], columns=['col1', 'col2'])\n</code></pre> Creates an empty DataFrame with specified index and columns.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-13-from-scalar","title":"DCMS-13: From Scalar","text":"<p><pre><code>pd.DataFrame({'col1': 1}, index=[0, 1, 2])\n</code></pre> Creates a DataFrame by broadcasting scalar values across specified indices.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-14-copy-constructor","title":"DCMS-14: Copy Constructor","text":"<p><pre><code>pd.DataFrame(other_df)\n</code></pre> Creates a DataFrame as a copy of another DataFrame.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-15-from-records","title":"DCMS-15: From Records","text":"<p><pre><code>pd.DataFrame.from_records([('a', 1), ('b', 2)], columns=['col1', 'col2'])\n</code></pre> Creates a DataFrame from a structured array, records, or sequence of tuples.</p> <p>Not Supported </p>"},{"location":"features/dataframe_creation_methods/#dcms-16-from-dict","title":"DCMS-16: From Dict","text":"<p><pre><code>pd.DataFrame.from_dict({'col1': [1, 2], 'col2': [3, 4]})\n</code></pre> Creates a DataFrame from a dictionary using the class method.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/","title":"Edge Cases","text":""},{"location":"features/edge_cases/#ec-1-multiindex-columns","title":"EC-1: MultiIndex columns","text":"<p><pre><code>df.columns = pd.MultiIndex.from_tuples([('A', 'one'), ('A', 'two'), ('B', 'one')])\n</code></pre> Creates complex hierarchical column structures that require special handling.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-2-rename-operations","title":"EC-2: Rename operations","text":"<p><pre><code>df = df.rename(columns={'old': 'new'})\n</code></pre> Changes column names while preserving their data and position.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-3-set-operations","title":"EC-3: Set operations","text":"<p><pre><code>df.columns = ['A', 'B', 'C']\n</code></pre> Completely replaces the column structure with a new set of names.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-4-arithmetic-operations","title":"EC-4: Arithmetic operations","text":"<p><pre><code>df['C'] = df['A'] + df['B']\n</code></pre> Creates new columns through arithmetic operations on existing columns.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-5-string-accessor","title":"EC-5: String accessor","text":"<p><pre><code>df[['first', 'last']] = df['name'].str.split(expand=True)\n</code></pre> Expands string content into multiple new columns.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-6-json-normalization","title":"EC-6: JSON normalization","text":"<p><pre><code>pd.json_normalize(data)\n</code></pre> Creates columns with nested names from hierarchical data.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-7-pivot-operations","title":"EC-7: Pivot operations","text":"<p><pre><code>df.pivot_table(index='date', columns='category', values='amount')\n</code></pre> Dramatically reshapes the column structure based on unique values.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-8-stackunstack","title":"EC-8: Stack/unstack","text":"<p><pre><code>df = df.stack().unstack(level=0)\n</code></pre> Converts between index levels and columns, potentially changing column names.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-9-transpose","title":"EC-9: Transpose","text":"<p><pre><code>df = df.T\n</code></pre> Swaps rows and columns, turning row indices into column names.</p> <p>Not Supported </p>"},{"location":"features/edge_cases/#ec-10-column-assignment-in-chain","title":"EC-10: Column assignment in chain","text":"<p><pre><code>df.assign(B=1).assign(C=lambda x: x['B']*2)\n</code></pre> Creates columns that depend on columns created earlier in the same chain.</p> <p>Not Supported </p>"}]}